// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Env = require("../Lib/Env.js");
var Url = require("url");
var Json = require("@glennsl/bs-json/src/Json.bs.js");
var Util = require("../Lib/Util.js");
var Redis = require("../External/Redis.js");
var Moment = require("moment");
var Npmlog = require("npmlog");
var Request = require("../External/Request.js");
var Database = require("../Lib/Database.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function saveBlock(isIrreversible, json) {
  Util.doNothing(isIrreversible);
  ((json._key = json.block_num + ""));
  ((json.irreversible = isIrreversible));
  var saveOpts = {
    overwrite: true
  };
  return Database.db.collection("blocks").save(json, saveOpts);
}

function fetchBlock(endpoint, num) {
  return Util.promiseToOption(Request.make(new Url.URL("/v1/chain/get_block", endpoint).toString(), "POST", undefined, Json.stringify(Json_encode.object_(/* :: */[
                            /* tuple */[
                              "block_num_or_id",
                              num
                            ],
                            /* [] */0
                          ])), 5000, undefined, undefined, true, /* () */0).then((function (response) {
                    return Util.parseJsonAsPromise(response.body).then((function (json) {
                                  return Promise.resolve(/* tuple */[
                                              json,
                                              Belt_Option.getWithDefault(Belt_Option.map(Js_primitive.nullable_to_opt(response.timings), (function (prim) {
                                                          return prim.end;
                                                        })), Env.throttleTime)
                                            ]);
                                }));
                  })));
}

var redis = Redis.make(/* () */0);

function fetchNextBlock(endpoint) {
  return redis.spopAsync("blockNums").then((function (blockNum) {
                    if (blockNum == null) {
                      Npmlog.info("FetchBlocks", "Block num queue is empty", "");
                      return Promise.resolve(Env.throttleTime);
                    } else {
                      return fetchBlock(endpoint, Caml_format.caml_int_of_string(blockNum)).then((function (blockOpt) {
                                    if (blockOpt !== undefined) {
                                      var match = blockOpt;
                                      var responseTime = match[1];
                                      return saveBlock(true, match[0]).then((function () {
                                                    var throttleTime = responseTime * Env.responseTimeMultiplier;
                                                    return Promise.resolve(throttleTime | 0);
                                                  }));
                                    } else {
                                      return redis.saddAsync("blockNums", /* array */[blockNum]).then((function () {
                                                    Npmlog.error("FetchBlocks", "Error fetching block from " + (String(endpoint) + (", added block " + (String(blockNum) + " back to the queue."))), "");
                                                    return Promise.resolve(Env.throttleTime);
                                                  }));
                                    }
                                  }));
                    }
                  })).then(Util.timeoutPromise).then((function () {
                return fetchNextBlock(endpoint);
              }));
}

Promise.all(Belt_Array.map(Env.endpoints, fetchNextBlock)).then((function () {
        return Promise.resolve((Npmlog.info("FetchBlocks", "Done", ""), /* () */0));
      }));

function getBlockCount() {
  return Database.db.query("RETURN LENGTH(blocks)").then((function (prim) {
                  return prim.next();
                })).then((function (json) {
                return Promise.resolve(Belt_Option.getWithDefault(Belt_Option.map((json == null) ? undefined : Js_primitive.some(json), Json_decode.$$int), 0));
              }));
}

function estimateTimeToComplete(numBlocksInQueue, blocksPerSecond) {
  var now = Date.now();
  var secFromNow = Caml_int32.div(numBlocksInQueue, blocksPerSecond);
  var endTime = now + secFromNow * 1000;
  var endDate = new Date(endTime);
  return Moment(endDate).fromNow();
}

function reportStats() {
  return getBlockCount(/* () */0).then((function (numBlocks) {
                return Util.timeoutPromise(Env.reportStatsTimeout).then((function () {
                                return Promise.all(/* tuple */[
                                            getBlockCount(/* () */0),
                                            redis.scardAsync("blockNums")
                                          ]);
                              })).then((function (param) {
                              var numInQueue = param[1];
                              var newBlockCount = param[0];
                              var numNewBlocks = newBlockCount - numBlocks | 0;
                              var blocksPerSecond = Caml_int32.div(numNewBlocks, Env.reportStatsTimeout / 1000 | 0);
                              var timeLeft = estimateTimeToComplete(numInQueue, blocksPerSecond);
                              new Date().toISOString();
                              var message = "------------------------\n" + (String(blocksPerSecond) + (" blocks per second\n" + (String(newBlockCount) + (" blocks in ArangoDB\n" + (String(numInQueue) + (" in Redis queue\nShould finish " + (String(timeLeft) + "\n")))))));
                              Npmlog.info("FetchBlocks", message, "");
                              return reportStats(/* () */0);
                            }));
              }));
}

reportStats(/* () */0);

exports.saveBlock = saveBlock;
exports.fetchBlock = fetchBlock;
exports.redis = redis;
exports.fetchNextBlock = fetchNextBlock;
exports.getBlockCount = getBlockCount;
exports.estimateTimeToComplete = estimateTimeToComplete;
exports.reportStats = reportStats;
/* redis Not a pure module */
