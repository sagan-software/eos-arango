// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Env = require("../Lib/Env.js");
var Url = require("url");
var Json = require("@glennsl/bs-json/src/Json.bs.js");
var Util = require("../Lib/Util.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Moment = require("moment");
var Npmlog = require("npmlog");
var Request = require("../External/Request.js");
var Endpoints = require("../Lib/Endpoints.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function initialState(endpoints) {
  return Belt_Array.map(endpoints, Endpoints.initialState);
}

var emptyState = /* array */[];

function fetchBlock(endpoint, num) {
  return Util.promiseToOption(Request.make(new Url.URL("/v1/chain/get_block", endpoint).toString(), "POST", undefined, Json.stringify(Json_encode.object_(/* :: */[
                            /* tuple */[
                              "block_num_or_id",
                              num
                            ],
                            /* [] */0
                          ])), 5000, undefined, undefined, true, true, /* () */0).then((function (response) {
                    return Util.parseJsonAsPromise(response.body).then((function (json) {
                                  return Promise.resolve(/* tuple */[
                                              json,
                                              Belt_Option.getWithDefault(Belt_Option.map(Js_primitive.nullable_to_opt(response.timings), (function (prim) {
                                                          return prim.end;
                                                        })), Env.throttleTime)
                                            ]);
                                }));
                  })));
}

function fetchNextBlock(endpoint) {
  return Curry._1(Env.Q[/* pop */2], /* () */0).then((function (blockNum) {
                    if (blockNum !== undefined) {
                      var blockNum$1 = blockNum;
                      return fetchBlock(endpoint, blockNum$1).then((function (blockOpt) {
                                      if (blockOpt !== undefined) {
                                        var match = blockOpt;
                                        var responseTime = match[1];
                                        var block = match[0];
                                        var exit = 0;
                                        var actualBlockNum;
                                        try {
                                          actualBlockNum = Json_decode.field("block_num", Json_decode.$$int, block);
                                          exit = 1;
                                        }
                                        catch (exn){
                                          return Curry._1(Env.Q[/* push */1], /* array */[blockNum$1]).then((function () {
                                                        Npmlog.error("FetchBlocks", "Couldn\'t decode block number from response from " + (String(endpoint) + (" for block " + (String(blockNum$1) + ""))), block);
                                                        return Promise.resolve(Env.throttleTime);
                                                      }));
                                        }
                                        if (exit === 1) {
                                          if (blockNum$1 === actualBlockNum) {
                                            ((block.irreversible = true));
                                            return Curry._1(Env.Db[/* save */2], block).then((function () {
                                                            var throttleTime = responseTime * Env.responseTimeMultiplier;
                                                            return Promise.resolve(throttleTime | 0);
                                                          })).catch((function (error) {
                                                          Npmlog.error("FetchBlocks", "Error saving block from " + (String(endpoint) + (" to DB, added block " + (String(blockNum$1) + " back to the queue."))), error);
                                                          return Promise.resolve(Env.throttleTime);
                                                        }));
                                          } else {
                                            return Curry._1(Env.Q[/* push */1], /* array */[blockNum$1]).then((function () {
                                                          Npmlog.error("FetchBlocks", "Received unexpected block number " + (String(actualBlockNum) + (" when fetching block " + (String(blockNum$1) + (" from " + (String(endpoint) + ""))))), "");
                                                          return Promise.resolve(Env.throttleTime);
                                                        }));
                                          }
                                        }
                                        
                                      } else {
                                        return Curry._1(Env.Q[/* push */1], /* array */[blockNum$1]).then((function () {
                                                      Npmlog.error("FetchBlocks", "Error fetching block from " + (String(endpoint) + (", added block " + (String(blockNum$1) + " back to the queue."))), "");
                                                      return Promise.resolve(Env.throttleTime);
                                                    }));
                                      }
                                    })).catch((function (error) {
                                    return Curry._1(Env.Q[/* push */1], /* array */[blockNum$1]).then((function () {
                                                  Npmlog.error("FetchBlocks", "Error fetching block from " + (String(endpoint) + (", added block " + (String(blockNum$1) + " back to the queue."))), error);
                                                  return Promise.resolve(Env.throttleTime);
                                                }));
                                  }));
                    } else {
                      return Promise.resolve(Env.throttleTime);
                    }
                  })).then(Util.timeoutPromise).then((function () {
                return fetchNextBlock(endpoint);
              }));
}

function estimateTimeToComplete(numBlocksInQueue, blocksPerSecond) {
  var now = Date.now();
  var secFromNow = Caml_int32.div(numBlocksInQueue, blocksPerSecond);
  var endTime = now + secFromNow * 1000;
  var endDate = new Date(endTime);
  return Moment(endDate).fromNow();
}

function reportStats() {
  return Curry._1(Env.Db[/* count */1], /* () */0).then((function (numBlocks) {
                return Util.timeoutPromise(Env.reportStatsTimeout).then((function () {
                                return Promise.all(/* tuple */[
                                            Curry._1(Env.Db[/* count */1], /* () */0),
                                            Curry._1(Env.Q[/* count */0], /* () */0)
                                          ]);
                              })).then((function (param) {
                              var numInQueue = param[1];
                              var newBlockCount = param[0];
                              var numNewBlocks = newBlockCount - numBlocks | 0;
                              var blocksPerSecond = Caml_int32.div(numNewBlocks, Env.reportStatsTimeout / 1000 | 0);
                              var timeLeft = estimateTimeToComplete(numInQueue, blocksPerSecond);
                              new Date().toISOString();
                              var message = "------------------------\n        " + (String(blocksPerSecond) + (" blocks per second\n            " + (String(newBlockCount) + (" blocks in ArangoDB\n            " + (String(numInQueue) + (" in Redis queue\nShould finish " + (String(timeLeft) + "\n")))))));
                              Npmlog.info("FetchBlocks", message, "");
                              return reportStats(/* () */0);
                            }));
              }));
}

Curry._1(Env.Db[/* setup */0], /* () */0).then((function () {
        Npmlog.info("FetchBlocks", "Database setup", "");
        return Promise.all(Belt_Array.map(Env.endpoints, fetchNextBlock)).then((function () {
                      return Promise.resolve((Npmlog.info("FetchBlocks", "Done", ""), /* () */0));
                    }));
      }));

reportStats(/* () */0);

exports.initialState = initialState;
exports.emptyState = emptyState;
exports.fetchBlock = fetchBlock;
exports.fetchNextBlock = fetchNextBlock;
exports.estimateTimeToComplete = estimateTimeToComplete;
exports.reportStats = reportStats;
/*  Not a pure module */
