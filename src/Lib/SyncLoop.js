// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Env = require("./Env.js");
var Util = require("./Util.js");
var Moment = require("moment");
var Npmlog = require("npmlog");
var Database = require("./Database.js");
var Endpoints = require("./Endpoints.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

var initialState = Endpoints.initialStates(Env.endpoints);

function estimateTimeToComplete(numBlocksInQueue, numValidEndpoints) {
  var now = Date.now();
  var numBlocksPerEndpoint = numBlocksInQueue / numValidEndpoints;
  var msFromNow = numBlocksPerEndpoint * Env.throttleTime;
  var endTime = now + msFromNow;
  var endDate = new Date(endTime);
  Npmlog.info("SyncLoop", "Expecting to fetch " + (String(numBlocksInQueue) + (" blocks from " + (String(numValidEndpoints) + " endpoints"))), Moment(endDate).fromNow());
  return /* () */0;
}

function start(endpoints) {
  return Promise.all(/* tuple */[
                  Database.getLargestBlockNum(/* () */0),
                  Endpoints.updateInfoForStates(endpoints)
                ]).then((function (param) {
                  var endpoints = param[1];
                  var largestDbBlockNum = param[0];
                  Npmlog.info("SyncLoop", "Largest block number from database:", largestDbBlockNum);
                  var largestEndpointBlockNums = Endpoints.getLargestBlockNums(endpoints);
                  Npmlog.info("SyncLoop", "Largest block number from endpoints:", largestEndpointBlockNums[/* head */0]);
                  var startBlockNum = Caml_primitive.caml_int_min(largestDbBlockNum + 1 | 0, largestEndpointBlockNums[/* irreversible */1]);
                  var numBlocksDifference = largestEndpointBlockNums[/* head */0] - startBlockNum | 0;
                  var numBlocksToFetch = Env.maxBlocksPerCycle < numBlocksDifference ? Env.maxBlocksPerCycle : numBlocksDifference;
                  Npmlog.info("SyncLoop", "Number of blocks to fetch in this cycle:", numBlocksToFetch);
                  var okEndpoints = Endpoints.onlyWithInfo(endpoints);
                  var numValidEndpoints = okEndpoints.length;
                  estimateTimeToComplete(numBlocksToFetch, numValidEndpoints);
                  var numBlocksPerEndpoint = Caml_int32.div(numBlocksToFetch, numValidEndpoints);
                  return Promise.all(Belt_Array.mapWithIndex(okEndpoints, (function (index, param) {
                                    var endpoint = param[0];
                                    var begin_ = Caml_int32.imul(index, numBlocksPerEndpoint) + startBlockNum | 0;
                                    var end_ = begin_ + numBlocksPerEndpoint | 0;
                                    return Belt_Array.reduce(Belt_Array.range(begin_, end_), Promise.resolve(endpoint), (function (result, blockNum) {
                                                  return result.then((function (state) {
                                                                  return Endpoints.getBlock(state, blockNum);
                                                                })).then((function (blockResult) {
                                                                var match = blockResult[/* block */2];
                                                                if (match !== undefined) {
                                                                  var isIrreversible = blockNum <= largestEndpointBlockNums[/* irreversible */1];
                                                                  return Database.saveBlock(isIrreversible, Js_primitive.valFromOption(match)).then((function () {
                                                                                  return Util.timeoutPromise(Env.throttleTime);
                                                                                })).then((function () {
                                                                                return Promise.resolve(blockResult[/* state */0]);
                                                                              }));
                                                                } else {
                                                                  Npmlog.error("SyncLoop", "Didn\'t fetch block " + (String(blockNum) + " from endpoint:"), endpoint[/* endpoint */0]);
                                                                  return Util.timeoutPromise(Env.throttleTime).then((function () {
                                                                                return Promise.resolve(blockResult[/* state */0]);
                                                                              }));
                                                                }
                                                              }));
                                                }));
                                  })));
                })).then((function () {
                Npmlog.info("SyncLoop", "Restarting...", "");
                return start(endpoints);
              }));
}

exports.initialState = initialState;
exports.estimateTimeToComplete = estimateTimeToComplete;
exports.start = start;
/* initialState Not a pure module */
